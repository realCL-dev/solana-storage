import * as anchor from '@coral-xyz/anchor' // Imports the Anchor framework for Solana program development.
import { Program } from '@coral-xyz/anchor' // Imports the Program type from Anchor.
import { SolanaStorage } from '../target/types/solana_storage' // Imports the IDL (Interface Definition Language) for the Solana program. 
// This is generated by Anchor and defines the program's instructions and 
// accounts.
import { expect } from 'chai' // Imports the 'expect' assertion library from Chai, commonly used for writing tests.

// Defines a test suite for the 'solana-storage' program.
describe('solana-storage', () => {
  // Declare variables that will be used across different test cases.
  let fetchedAccount, provider, storageAccount, program

  // This block runs before each test case. It sets up the necessary environment for testing.
  beforeEach(async () => {
    // Get the Anchor provider from the environment. 
    // This typically uses the `ANCHOR_PROVIDER_URL` and `ANCHOR_WALLET` environment variables.
    provider = anchor.AnchorProvider.env()
    // Sets the global Anchor provider.
    anchor.setProvider(provider)

    // Casts the workspace program to the SolanaStorage program type.
    program = anchor.workspace.solanaStorage as Program<SolanaStorage>

    // Generates a new keypair for the storage account. This will be the account that holds the `StoredData` struct.
    const StorageAccount = anchor.web3.Keypair.generate()

    // Extracts the public key from the newly generated keypair.
    storageAccount = StorageAccount.publicKey

    // Calls the `storeInitialValue` instruction of the Solana program.
    await program.methods
      .storeInitialValue() // Specifies the instruction to call.
      .accounts({
        // Provides the accounts required by the `storeInitialValue` instruction.
        storageBalance: storageAccount, // The new account to be initialized.
        admin: provider.wallet.publicKey, // The admin (payer) for creating the account.
        systemProgram: anchor.web3.SystemProgram.programId // The Solana System Program, needed for creating new 
        // accounts.
      })
      .signers([StorageAccount]) // Signs the transaction with the `StorageAccount` keypair because it's being 
      // initialized.
      .rpc() // Sends the transaction to the Solana cluster.

    // Fetches the data from the `storageAccount` after the `storeInitialValue` instruction has been executed.
    fetchedAccount = await program.account.storedData.fetch(storageAccount)
  })

  // Test case 1: Checks if the storage_balance account is initialized with the correct initial value.
  it('Initializes the storage_balance account with the correct value!', async () => {
    // Asserts that the 'storedValue' in the fetched account is equal to 100.
    // `.toNumber()` is used because Anchor often returns U64 values as BN (BigNumber) objects.
    expect(fetchedAccount.storedValue.toNumber()).to.equal(
      100,
      'The stored value should be 100' // Custom error message if the assertion fails.
    )
    // Logs a success message to the console.
    console.log(
      "Successfully initialized 'storage_balance' with stored_value:",
      fetchedAccount.storedValue.toNumber()
    )
  })

  // Test case 2: Checks if the `stored_value` updates correctly within the defined bounds.
  it('Updates the stored_value correctly when within bounds', async () => {
    // Loops 8 times to simulate multiple updates.
    for (let i = 1; i <= 8; i++) {
      // Calls the `updateValue` instruction of the Solana program.
      await program.methods
        .updateValue()
        .accounts({
          // Provides the accounts required by the `updateValue` instruction.
          storageBalance: storageAccount, // The existing storage account to update.
          admin: provider.wallet.publicKey, // The admin (payer) for the transaction fee.
          systemProgram: anchor.web3.SystemProgram.programId // The Solana System Program.
        })
        .rpc() // Sends the transaction.

      // Fetches the updated data from the `storageAccount`.
      fetchedAccount = await program.account.storedData.fetch(storageAccount)
      // Asserts that the 'storedValue' has increased by 100 in each iteration.
      expect(fetchedAccount.storedValue.toNumber()).to.equal(
        i * 100 + 100, // Calculates the expected value: initial (100) + i * 100.
        `Stored value should be ${i * 100 + 100} after ${i} update(s)`
      )
      // Logs the current stored value after each update.
      console.log(
        `Stored value after ${i} update(s): ${fetchedAccount.storedValue.toNumber()}`
      )
    }
    // Logs the final stored value after all 8 updates.
    console.log(
      `Stored value after 8 updates: ${fetchedAccount.storedValue.toNumber()}`
    )
  })

  // Test case 3: Checks if the program correctly throws an error when attempting to increment beyond 
  // the `max_value`.
  it('Throws an error when incrementing beyond the bound set', async () => {
    // This loop brings the `stored_value` up to its maximum (1000).
    for (let i = 1; i <= 8; i++) {
      await program.methods
        .updateValue()
        .accounts({
          storageBalance: storageAccount,
          admin: provider.wallet.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId
        })
        .rpc()
      fetchedAccount = await program.account.storedData.fetch(storageAccount)
      expect(fetchedAccount.storedValue.toNumber()).to.equal(
        i * 100 + 100,
        `Stored value should be ${i * 100 + 100} after ${i} update(s)`
      )
    }

    // This block attempts to call `updateValue` one more time, which should exceed the `max_value`.
    try {
      await program.methods
        .updateValue()
        .accounts({
          storageBalance: storageAccount,
          admin: provider.wallet.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId
        })
        .rpc()
      // If the `rpc()` call above does NOT throw an error, then the test should fail.
      throw new Error("Expected transaction to fail with MaxValueExceeded")
    } catch (error: any) { // Catches any error thrown by the transaction.
      // Asserts that the error message includes "MaxValueExceeded", which is the custom error 
      // defined in the program.
      expect(error.message).to.include("MaxValueExceeded")
    }

    // After the expected error, fetch the account again to confirm the value is still capped at 1000.
    fetchedAccount = await program.account.storedData.fetch(storageAccount)
    expect(fetchedAccount.storedValue.toNumber()).to.equal(1000, "value should be capped at 1000")
    // Logs the value after the failed attempt to update.
    console.log(
      `Stored value after error attempt: ${fetchedAccount.storedValue.toNumber()}`
    )
  })
})